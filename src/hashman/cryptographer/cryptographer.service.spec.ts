import { Test, TestingModule } from '@nestjs/testing';
import { CryptographerService } from './cryptographer.service';
import { EncryptionResult } from '../interfaces';
import * as faker from 'faker';
import { CryptoAlgorithm } from '../constants';

const UNSUPPORTED_STATE_ERROR_MSG =
  'Unsupported state or unable to authenticate data';

const createTestModule = async ({
  secretKey,
  algorithm,
  iv,
}: {
  secretKey: string;
  algorithm?: CryptoAlgorithm;
  iv?: Buffer;
}) => {
  return Test.createTestingModule({
    providers: [
      {
        provide: CryptographerService,
        useValue: new CryptographerService(
          secretKey,
          algorithm,
          iv && iv.toString('utf-8'),
        ),
      },
    ],
  }).compile();
};

const getCryptographerService = (module: TestingModule) => {
  return module.get<CryptographerService>(CryptographerService);
};

describe('DefaultCryptographerService', () => {
  const secretKey = 'test-secret';
  const iv = Buffer.from('test-initialization-vector').slice(0, 16);
  const algorithm = CryptoAlgorithm.AES_192_GCM;

  let service: CryptographerService;

  beforeEach(async () => {
    const module: TestingModule = await createTestModule({
      secretKey,
      algorithm,
      iv,
    });

    service = getCryptographerService(module);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });

  it.each([
    CryptoAlgorithm.AES_128_GCM,
    CryptoAlgorithm.AES_192_GCM,
    CryptoAlgorithm.AES_256_GCM,
  ])(
    'should encrypt and decrypt value: %s',
    async (algorithm: CryptoAlgorithm) => {
      const valueToEncrypt = faker.company.companyName();

      const encResult: EncryptionResult = await service.encrypt({
        value: valueToEncrypt,
        algorithm,
      });

      const decryptedValue: Buffer = await service.decrypt({
        value: encResult.value,
        authTag: encResult.authTag,
        algorithm,
      });

      expect(decryptedValue.toString('utf-8')).toBe(valueToEncrypt);
    },
  );

  it.each([
    {
      alg: CryptoAlgorithm.AES_128_GCM,
      expectedValue: 'dj/B2XUfPptDrfMEoIiDcg==',
      expectedAuthTag: 'Av152spQsaEffTeVFTvcLA==',
    },
    {
      alg: CryptoAlgorithm.AES_192_GCM,
      expectedValue: 'aHmQaywOUcPVD3un87rleQ==',
      expectedAuthTag: 'Bwuzo3FaXxKdPJXbkKD7pg==',
    },
    {
      alg: CryptoAlgorithm.AES_256_GCM,
      expectedValue: 'eeh44+VGqJJjBwKZPQO+bg==',
      expectedAuthTag: '2IZABxG/yy87q0aiDWC9GA==',
    },
  ])(
    'should encrypt value',
    async ({ alg: algorithm, expectedValue, expectedAuthTag }) => {
      const valueToEncrypt = 'some-test-secret';

      const encResult: EncryptionResult = await service.encrypt({
        value: valueToEncrypt,
        algorithm,
      });

      const expectedResult: EncryptionResult = {
        value: Buffer.from(expectedValue, 'base64'),
        authTag: Buffer.from(expectedAuthTag, 'base64'),
        iv,
        algorithm,
      };

      expect(encResult).toEqual(expectedResult);
    },
  );

  it('should get same encrypted value with fixed IV', async () => {
    const valueToEncrypt = faker.company.companyName();

    const encResult: EncryptionResult = await service.encrypt({
      value: valueToEncrypt,
    });
    const encResultWithSameIV: EncryptionResult = await service.encrypt({
      value: valueToEncrypt,
    });

    expect(encResult).toEqual(encResultWithSameIV);
  });

  it('should get different encrypted value with different autogenerated IV', async () => {
    const valueToEncrypt = faker.company.companyName();

    const module: TestingModule = await createTestModule({
      secretKey,
      iv: null,
    });

    service = getCryptographerService(module);

    const encResult: EncryptionResult = await service.encrypt({
      value: valueToEncrypt,
    });
    const encResultWithAnotherIV: EncryptionResult = await service.encrypt({
      value: valueToEncrypt,
    });

    expect(encResult).not.toEqual(encResultWithAnotherIV);
  });

  it('should fail to decrypt value with invalid IV', async () => {
    const encryptedValue: EncryptionResult = await service.encrypt({
      value: faker.company.companyName(),
    });

    const invalidIV = Buffer.alloc(16);

    await expect(async () => {
      await service.decrypt({
        value: encryptedValue.value,
        authTag: encryptedValue.authTag,
        algorithm: encryptedValue.algorithm,
        iv: invalidIV,
      });
    }).rejects.toThrowError(UNSUPPORTED_STATE_ERROR_MSG);
  });

  it('should fail to decrypt value with invalid auth tag', async () => {
    const encryptedValue: EncryptionResult = await service.encrypt({
      value: faker.company.companyName(),
    });

    const invalidAuthTag = Buffer.alloc(encryptedValue.authTag.length);

    await expect(async () => {
      await service.decrypt({
        value: encryptedValue.value,
        authTag: invalidAuthTag,
        algorithm: encryptedValue.algorithm,
        iv: encryptedValue.iv,
      });
    }).rejects.toThrowError(UNSUPPORTED_STATE_ERROR_MSG);
  });

  it('should fail to decrypt value if auth tag length is invalid', async () => {
    const encryptedValue: EncryptionResult = await service.encrypt({
      value: faker.company.companyName(),
    });

    const invalidAuthTag = Buffer.alloc(encryptedValue.authTag.length + 1);

    await expect(async () => {
      await service.decrypt({
        value: encryptedValue.value,
        authTag: invalidAuthTag,
        algorithm: encryptedValue.algorithm,
        iv: encryptedValue.iv,
      });
    }).rejects.toThrowError(/Invalid authentication tag length/);
  });

  it('should fail to decrypt invalid encrypted value', async () => {
    const encryptedValue: EncryptionResult = await service.encrypt({
      value: faker.company.companyName(),
    });

    const invalidEncryptedValue = Buffer.concat([
      encryptedValue.value,
      Buffer.from(faker.random.alpha()),
    ]);

    await expect(async () => {
      await service.decrypt({
        value: invalidEncryptedValue,
        authTag: encryptedValue.authTag,
        algorithm: encryptedValue.algorithm,
        iv: encryptedValue.iv,
      });
    }).rejects.toThrowError(UNSUPPORTED_STATE_ERROR_MSG);
  });

  it('should fail to decrypt value if use inappropriate secret', async () => {
    const encryptedValue: EncryptionResult = await service.encrypt({
      value: faker.company.companyName(),
    });

    const invalidSecret = faker.datatype.hexaDecimal();

    await expect(async () => {
      await service.decrypt({
        value: encryptedValue.value,
        authTag: encryptedValue.authTag,
        algorithm: encryptedValue.algorithm,
        iv: encryptedValue.iv,
        secretKey: invalidSecret,
      });
    }).rejects.toThrowError(UNSUPPORTED_STATE_ERROR_MSG);
  });
});
