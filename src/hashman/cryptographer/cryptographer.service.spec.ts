import { Test, TestingModule } from '@nestjs/testing';
import { CryptographerService } from './cryptographer.service';
import { EncryptionResult } from '../interfaces/x-coder.interface';
import * as faker from 'faker';
import { CryptoAlgorithm } from '../constants/crypto-algorithm.enum';

const createTestModule = async ({
  secretKey,
  algorithm,
  iv,
}: {
  secretKey: string;
  algorithm?: CryptoAlgorithm;
  iv?: Buffer;
}) => {
  return Test.createTestingModule({
    providers: [
      {
        provide: CryptographerService,
        useValue: new CryptographerService(
          secretKey,
          algorithm,
          iv && iv.toString('utf-8'),
        ),
      },
    ],
  }).compile();
};

const getCryptographerService = (module: TestingModule) => {
  return module.get<CryptographerService>(CryptographerService);
};

describe('DefaultCryptographerService', () => {
  const secretKey = 'test-secret';
  const iv = Buffer.from('test-initialization-vector').slice(0, 16);
  const algorithm = CryptoAlgorithm.AES_192_GCM;

  let service: CryptographerService;

  beforeEach(async () => {
    const module: TestingModule = await createTestModule({
      secretKey,
      algorithm,
      iv,
    });

    service = getCryptographerService(module);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });

  it('should encrypt and decrypt value', async () => {
    const valueToEncrypt = faker.company.companyName();

    const encResult: EncryptionResult = await service.encrypt({
      value: valueToEncrypt,
    });

    const decryptedValue: Buffer = await service.decrypt({
      value: encResult.value,
      authTag: encResult.authTag,
    });

    expect(decryptedValue.toString('utf-8')).toBe(valueToEncrypt);
  });

  it('should encrypt value', async () => {
    const valueToEncrypt = 'some-test-secret';

    const encResult: EncryptionResult = await service.encrypt({
      value: valueToEncrypt,
    });

    const expectedResult: EncryptionResult = {
      value: Buffer.from('aHmQaywOUcPVD3un87rleQ==', 'base64'),
      authTag: Buffer.from('Bwuzo3FaXxKdPJXbkKD7pg==', 'base64'),
      iv,
      algorithm,
    };

    expect(encResult).toEqual(expectedResult);
  });

  it('should get same encrypted value with fixed IV', async () => {
    const valueToEncrypt = faker.company.companyName();

    const encResult: EncryptionResult = await service.encrypt({
      value: valueToEncrypt,
    });
    const encResultWithSameIV: EncryptionResult = await service.encrypt({
      value: valueToEncrypt,
    });

    expect(encResult).toEqual(encResultWithSameIV);
  });

  it('should get different encrypted value with different autogenerated IV', async () => {
    const valueToEncrypt = faker.company.companyName();

    const module: TestingModule = await createTestModule({
      secretKey,
      iv: null,
    });

    service = getCryptographerService(module);

    const encResult: EncryptionResult = await service.encrypt({
      value: valueToEncrypt,
    });
    const encResultWithAnotherIV: EncryptionResult = await service.encrypt({
      value: valueToEncrypt,
    });

    expect(encResult).not.toEqual(encResultWithAnotherIV);
  });
});
