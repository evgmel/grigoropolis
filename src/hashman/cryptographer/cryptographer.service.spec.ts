import { Test, TestingModule } from '@nestjs/testing';
import { CryptographerService } from './cryptographer.service';
import { EncryptionResult } from '../interfaces/x-coder.interface';
import * as faker from 'faker';
import { CryptoAlgorithm } from '../constants/crypto-algorithm.enum';

const createTestModule = async ({
  secretKey,
  algorithm,
  iv,
}: {
  secretKey: string;
  algorithm?: CryptoAlgorithm;
  iv?: Buffer;
}) => {
  return Test.createTestingModule({
    providers: [
      {
        provide: CryptographerService,
        useValue: new CryptographerService(
          secretKey,
          algorithm,
          iv && iv.toString('utf-8'),
        ),
      },
    ],
  }).compile();
};

const getCryptographerService = (module: TestingModule) => {
  return module.get<CryptographerService>(CryptographerService);
};

describe('DefaultCryptographerService', () => {
  const secretKey = 'test-secret';
  const iv = Buffer.from('test-initialization-vector').slice(0, 16);
  const algorithm = CryptoAlgorithm.AES_192_GCM;

  let service: CryptographerService;

  beforeEach(async () => {
    const module: TestingModule = await createTestModule({
      secretKey,
      algorithm,
      iv,
    });

    service = getCryptographerService(module);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });

  it.each([
    CryptoAlgorithm.AES_128_GCM,
    CryptoAlgorithm.AES_192_GCM,
    CryptoAlgorithm.AES_256_GCM,
  ])(
    'should encrypt and decrypt value: %s',
    async (algorithm: CryptoAlgorithm) => {
      const valueToEncrypt = faker.company.companyName();

      const encResult: EncryptionResult = await service.encrypt({
        value: valueToEncrypt,
        algorithm,
      });

      const decryptedValue: Buffer = await service.decrypt({
        value: encResult.value,
        authTag: encResult.authTag,
        algorithm,
      });

      expect(decryptedValue.toString('utf-8')).toBe(valueToEncrypt);
    },
  );

  it.each([
    {
      alg: CryptoAlgorithm.AES_128_GCM,
      expectedValue: 'dj/B2XUfPptDrfMEoIiDcg==',
      expectedAuthTag: 'Av152spQsaEffTeVFTvcLA==',
    },
    {
      alg: CryptoAlgorithm.AES_192_GCM,
      expectedValue: 'aHmQaywOUcPVD3un87rleQ==',
      expectedAuthTag: 'Bwuzo3FaXxKdPJXbkKD7pg==',
    },
    {
      alg: CryptoAlgorithm.AES_256_GCM,
      expectedValue: 'eeh44+VGqJJjBwKZPQO+bg==',
      expectedAuthTag: '2IZABxG/yy87q0aiDWC9GA==',
    },
  ])(
    'should encrypt value',
    async ({ alg: algorithm, expectedValue, expectedAuthTag }) => {
      const valueToEncrypt = 'some-test-secret';

      const encResult: EncryptionResult = await service.encrypt({
        value: valueToEncrypt,
        algorithm,
      });

      const expectedResult: EncryptionResult = {
        value: Buffer.from(expectedValue, 'base64'),
        authTag: Buffer.from(expectedAuthTag, 'base64'),
        iv,
        algorithm,
      };

      expect(encResult).toEqual(expectedResult);
    },
  );

  it('should get same encrypted value with fixed IV', async () => {
    const valueToEncrypt = faker.company.companyName();

    const encResult: EncryptionResult = await service.encrypt({
      value: valueToEncrypt,
    });
    const encResultWithSameIV: EncryptionResult = await service.encrypt({
      value: valueToEncrypt,
    });

    expect(encResult).toEqual(encResultWithSameIV);
  });

  it('should get different encrypted value with different autogenerated IV', async () => {
    const valueToEncrypt = faker.company.companyName();

    const module: TestingModule = await createTestModule({
      secretKey,
      iv: null,
    });

    service = getCryptographerService(module);

    const encResult: EncryptionResult = await service.encrypt({
      value: valueToEncrypt,
    });
    const encResultWithAnotherIV: EncryptionResult = await service.encrypt({
      value: valueToEncrypt,
    });

    expect(encResult).not.toEqual(encResultWithAnotherIV);
  });
});
